正课：
1.内存管理：由JVM来管理
	1)堆:
		1.1)存储new出来的对象(包括成员变量)
		1.2)成员变量的生命周期:
			创建对象时存在堆中，对象被回收时一并消失
		1.3)垃圾:没有任何引用指向的对象
		    垃圾回收器不定时到内存中清扫垃圾
		  回收过程是透明的，不一定发现垃圾就立刻回收
		  调用System.gc()可以建议JVM尽快调度GC来回收
		1.4)内存泄漏:不再使用的内存没有被及时回收
		建议:不再使用的对象需要及时把引用设置为null
	2)栈:
		2.1)存储正在调用中的方法中的所有局部变量(包括参数)
		2.2)调用方法时，会在栈中为该方法分配一块对应的栈帧
		栈帧中存储方法中所有的局部变量(包括参数)
		2.3)局部变量的生命周期:
		调用方法时存储在栈中，方法完之后和方法一块消失
	3)方法区:
		3.1)方法区存储的.class字节码文件(包括方法)
		3.2)方法只有一份，只加载一次
2.方法的重写:
	1)发生在父子类中，方法名参数都相同
	2)重写方法被调用时，看对象的类型

3.方法重写与重载:
重写-------Override
	1.1)发生在一个类中,方法名相同，参数列表相同
	1.2)重写遵循"运行期"绑定，看对象的类型来调用方法
重载-------Overload
	1.1)发生在一个类中，方法名相同，参数列表不同
	2.2)重载遵循"编译期"绑定，看引用的类型来绑定方法
	
编译期:.java经过编译变成.class
运行期:JVM加载.class并运行.class
class Aoo{
	void say();
}
class Boo extends Aoo{
	void say(String name){}//重载不是重写，因为Boo继承Aoo本来就具有say方法
}
	
4.package和import:
	建议:package
	域名反写.项目名.模块名.类名
	所有字母都小写
5.访问控制修饰符:
6.static:静态的
	1)静态变量:
		1.由static修饰
		2.通过类名.变量来访问
		3.属于类存在方法区中，只有一份
		4.何时用:所有对象共享的数据
	2)静态方法：
		1.由static修饰
		2.属于类，存在方法区，只有一份
		3.通过类名.来访问
		4.静态方法没有隐式的this传递,但是有隐式的包名加类名
		静态方法中不能直接访问实例变量
		5.何时用:方法的操作仅与参数有关和对象无关
		操作成员变量么?方法内有没有this
	3)静态块:
		1.由static修饰
		2.类被加载期间自动执行,因类只被加载一次
		所以静态块也只执行一次
		3.何时用:常常用于初始化资源
听得懂、忘得快、不会写-----欠练
7.final:
成员变量:
	类中，方法外
	创建对象时存在堆中，对象被回收时一并消失
	1)实例变量:没有static修饰，属于对象的，存在堆中
	2)静态变量:有static 修饰，属于类的，存在方法区，只有一份
	
	
局部变量：
	方法中
	方法调用时在栈中，调用完一并消失
	没有默认值